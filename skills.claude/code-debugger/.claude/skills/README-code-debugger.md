# Code Debugger - 使用指南

## 概述

`Code Debugger` 是一个基于深度上下文理解的智能调试与增量开发系统。与传统的"快速试错"式调试不同，它采用**上下文优先**的方法，在充分理解项目逻辑的前提下进行精准的问题修复和功能迭代。

## 核心特性

### 1. 上下文优先
- 深入分析代码结构、函数调用链、变量依赖关系
- 构建完整的上下文关系网络
- 所有修改都基于对代码的充分理解

### 2. 智能文档管理
- 自动创建和维护 `.debug` 文档
- 记录每次调试的历史、变量关系、解决方案
- 按功能模块隔离，避免混乱

### 3. 精准调试
- 基于完整上下文的问题定位
- 最小化修改原则
- 保持代码风格和架构一致性

### 4. 持续迭代
- 根据测试反馈持续优化
- 完整的 Debug 记录可追溯
- 形成项目知识库

## 调用方式

### 方式 1: Slash Command (推荐)

在你的项目中，直接输入：

```
/debug
```

然后描述你的调试或开发需求。

### 方式 2: 直接调用 Skill

在 Claude Code 中选择 `code-debugger` skill。

## 使用场景

### ✅ 适用场景

| 场景 | 示例 |
|------|------|
| Bug 修复 | "修复登录接口在并发情况下的超时问题" |
| 增量功能 | "为用户管理模块添加批量导入功能" |
| 性能优化 | "优化订单查询的性能问题" |
| 变量追踪 | "追踪 userSession 变量的生命周期" |
| 逻辑调试 | "调试订单计算的折扣逻辑错误" |

### ❌ 不适用场景

| 场景 | 建议使用 |
|------|----------|
| 全新项目从零开发 | `/ai-spec` |
| 简单的代码查询 | 通用搜索工具 |
| 与当前项目无关的独立任务 | 创建新项目 |

## 工作流程示例

### 示例 1: Bug 修复

```
用户: /debug
      修复用户登录后 session 丢失的问题

步骤 1: Context Builder 分析
- 识别涉及模块: auth, session, user
- 检查现有 .debug 文档
- 决定: 加载 .debug/auth-login-debug.md

步骤 2: 代码探索
- 定位关键文件: src/auth/login.ts
- 追踪 session 相关函数
- 构建变量依赖图

步骤 3: Debug Executor 执行
- 基于上下文定位问题
- 设计解决方案
- 实施代码修改

步骤 4: 验证与记录
- 验证修复效果
- 更新 .debug/auth-login-debug.md
- 记录测试结果
```

### 示例 2: 增量功能开发

```
用户: /debug
      为订单模块添加批量导出功能

步骤 1: Context Builder 分析
- 识别涉及模块: order, export, file
- 检查现有 .debug 文档
- 决定: 新建 .debug/order-export-debug.md

步骤 2: 代码探索
- 分析现有订单查询逻辑
- 研究项目现有的导出模式
- 构建数据流向图

步骤 3: Debug Executor 执行
- 设计批量导出方案
- 复用现有组件和工具
- 实施功能开发

步骤 4: 验证与记录
- 测试导出功能
- 更新 .debug/order-export-debug.md
- 记录实现细节
```

## .debug 文档结构

```
.debug/
├── auth-login-debug.md           # 认证登录模块
├── user-profile-debug.md         # 用户资料模块
├── order-api-debug.md            # 订单 API 模块
└── payment-gateway-debug.md      # 支付网关模块
```

每个文档包含：
- 元信息（模块名称、相关文件、依赖模块）
- 上下文关系网络（文件结构、函数调用链、变量依赖图）
- Debug 历史（每次调试的完整记录）
- 待追踪问题
- 技术债务记录
- 架构决策记录 (ADR)

## 模块隔离机制

为了防止模型幻觉引发连锁错误，系统采用模块隔离机制：

### 交叉度计算

```
交叉度 = (共享函数数 + 共享变量数 + 共享数据结构数) / 总组件数
```

### 决策规则

- 交叉度 > 30% → 合并到现有文档
- 交叉度 < 30% → 创建新文档

### 示例

```
任务 A: 修复登录超时问题 (auth-login-debug.md)
任务 B: 添加第三方登录 (auth-login-debug.md)
→ 共享函数: login(), validateSession()
→ 交叉度: 60%
→ 决策: 合并到 auth-login-debug.md

任务 C: 优化订单查询 (order-query-debug.md)
任务 A: 修复登录超时问题 (auth-login-debug.md)
→ 共享函数: 无
→ 交叉度: 0%
→ 决策: 创建独立的 order-query-debug.md
```

## 质量保证

### 代码修改检查清单

- [ ] 已阅读相关代码的完整上下文
- [ ] 已理解变量依赖关系
- [ ] 已评估修改的影响范围
- [ ] 代码风格与现有代码一致
- [ ] 已处理边界情况
- [ ] 已考虑错误处理
- [ ] 已进行测试验证
- [ ] 已更新 .debug 文档

### 风险控制

1. **最小化修改**：只修改必要的代码
2. **保持一致**：遵循现有的命名、结构、模式
3. **防御性编程**：添加必要的边界检查和错误处理
4. **完整记录**：所有修改都记录到 .debug 文档

## 最佳实践

### 1. 提供清晰的任务描述

❌ 不好的描述:
```
修复登录问题
```

✅ 好的描述:
```
修复用户登录后 session 丢失的问题。
具体表现：用户登录成功后，跳转到首页时提示未登录。
环境：生产环境，高并发场景。
```

### 2. 提供足够的上下文

如果可能，提供以下信息：
- 错误日志
- 复现步骤
- 预期行为 vs 实际行为
- 相关的配置或环境信息

### 3. 及时反馈测试结果

在系统提供解决方案后，请及时测试并提供反馈：
- 是否解决了问题？
- 是否有新的问题？
- 是否需要进一步优化？

### 4. 定期清理 .debug 文档

随着项目演进，某些旧的 Debug 文档可能不再需要。定期清理可以：
- 减少 context 加载时间
- 避免过时信息的干扰
- 保持文档的准确性

## 高级功能

### 技术债务追踪

系统会在 .debug 文档中记录技术债务：

```markdown
## 技术债务记录

| ID | 债务描述 | 影响 | 建议 | 状态 |
|----|----------|------|------|------|
| TD-1 | auth 函数缺少单元测试 | 中 | 添加测试覆盖 | 待处理 |
```

### 架构决策记录 (ADR)

重要的架构决策会记录在 .debug 文档中：

```markdown
## 架构决策记录

### ADR-001: 使用 JWT 替代 Session 存储

**状态**: 已接受

**上下文**:
原有 session 存储在 Redis 中，高并发下性能不足。

**决策**:
迁移到 JWT，token 存储在客户端。

**后果**:
- 正面: 减少 Redis 依赖，提升性能
- 负面: Token 撤销需要额外机制
- 风险: Token 泄漏风险
```

### 跨模块引用

当多个模块存在依赖时，.debug 文档会记录依赖关系：

```markdown
## 元信息
| **依赖模块** | .debug/payment-gateway-debug.md |
```

这样在调试时可以快速加载相关模块的上下文。

## 故障排除

### 问题 1: .debug 文档过于庞大

**原因**: 单个文档记录了太多不相关的问题

**解决方案**:
- 重新评估模块划分
- 拆分为多个更细粒度的文档
- 清理过时的历史记录

### 问题 2: 上下文加载缓慢

**原因**: 文档中记录了过多不必要的信息

**解决方案**:
- 只记录关键信息
- 使用更简洁的描述
- 定期清理历史记录

### 问题 3: 修复后引入新问题

**原因**: 上下文分析不完整，遗漏了某些依赖关系

**解决方案**:
- 重新运行上下文构建
- 检查模块依赖关系
- 更新变量依赖图

## 常见问题 (FAQ)

**Q: .debug 文档应该提交到版本控制吗？**

A: 建议提交。.debug 文档是项目知识库的一部分，提交到版本控制可以：
- 让团队成员共享调试经验
- 保留完整的问题追踪记录
- 便于代码审查和知识传承

**Q: 如何处理跨功能的复杂问题？**

A: 如果一个问题涉及多个模块，可以：
1. 在主要的模块文档中记录
2. 在其他模块文档中添加引用
3. 或者创建一个临时的跨模块调试文档

**Q: .debug 文档与常规文档（如 README）有什么区别？**

A:
- `.debug` 文档：聚焦于具体的调试历史、变量关系、实现细节
- 常规文档：聚焦于使用方法、架构设计、API 说明

两者互补，建议都维护。

## 贡献与反馈

如果你有任何问题或建议，欢迎反馈！

---

**Happy Debugging! 🐛✨**
