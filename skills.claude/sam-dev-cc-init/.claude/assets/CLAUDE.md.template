# CLAUDE.md
<!--
  WHAT: 这是AI助手的上下文指南，让Claude快速理解项目结构和开发规范
  WHY: 减少重复解释，保持开发一致性，实现高效的PDCA循环
  WHEN: 新项目初始化时创建，随着项目演进更新
-->

This file provides guidance to Claude Code when working with code in this repository.

## 快速开始

- 工作目录：`/app`
- 常用命令：
  - 测试：`pytest tests/ -v`
  - 运行：`python -m app.main`

## PDCO 开发循环（CHECKFIX 零错误部署）

<!--
  PDCO = Plan-Do-Check-Optimize
  核心理念：Context Window = RAM (易失，有限), Filesystem = Disk (持久，无限)
  关键改进：Do 阶段必须执行 CHECKFIX，Check 阶段验证 CHECKFIX 全部通过
  重要信息必须写入文件！
-->

```
┌─────────────────────────────────────────────────────────────┐
│             PDCO 开发循环（CHECKFIX 零错误）                 │
├─────────────────────────────────────────────────────────────┤
│  1. PLAN → 读取 tasks/TASKS.md，查看并领取任务              │
│  2. DO   → 代码修改 + 执行 CHECKFIX 检查清单                │
│  3. CHECK→ 验证 CHECKFIX 全部通过 + pytest/集成验证         │
│  4. OPT  → 更新 PROGRESS-LOG.md + 更新任务 + self.opt 沉淀   │
│                                                              │
│  🔴 核心原则：所有代码修改必须 CHECKFIX 零错误提交/部署      │
└─────────────────────────────────────────────────────────────┘
```

### 文件对应关系

| 阶段 | 文件 | 用途 | 更新方式 |
|------|------|------|----------|
| PLAN | `tasks/TASKS.md` | 任务列表与状态管理 | 手动编辑 |
| DO | 代码目录 | 实现 + **CHECKFIX 检查** | 编码 |
| CHECK | `.checkfix/` + `pytest` | **验证 CHECKFIX** + 测试 | 命令 |
| OPT | `PROGRESS-LOG.md` + `self.opt` | 进度日志 + 经验沉淀 | 手动编辑 |

## 三方同步系统（Worker-Inspector-Human）

### CLI 仪表盘查看反馈

所有 Inspector Agent 的反馈都可通过 CLI 显示，实现三方实时同步：

```bash
# 1. 查看当前 Agent 状态
.claude/scripts/inspector-cli.sh status

# 2. 查看最新反馈
.claude/scripts/inspector-cli.sh feedback excellent
.claude/scripts/inspector-cli.sh feedback alert
.claude/scripts/inspector-cli.sh feedback warning

# 3. 查看完整仪表盘
.claude/scripts/inspector-cli.sh dashboard

# 4. 查看三方同步状态
.claude/scripts/inspector-cli.sh sync all

# 5. 查看检查日志
.claude/scripts/inspector-cli.sh log

# 6. 查看绩效对比
.claude/scripts/inspector-cli.sh compare
```

### 三方角色

| 角色 | 职责 | 交互方式 |
|------|------|---------|
| **Worker Agent** | 执行任务、写代码、运行CHECKFIX | 接收 Inspector 反馈，自动调整 |
| **Inspector Agent** | 评估质量、生成反馈、追踪趋势 | 输出结构化评估到 CLI |
| **Human** | 监督、决策、干预 | 通过 CLI 仪表盘实时监测 |

---

## 每日启动流程

```bash
# 1. 查看 Agent 当前状态和预算
.claude/scripts/inspector-cli.sh status

# 2. 查看完整仪表盘（performance snapshot）
.claude/scripts/inspector-cli.sh dashboard

# 3. 查看今日任务
cat tasks/TASKS.md | grep -A 10 "当前 Sprint"

# 4. 回顾昨日进度
cat PROGRESS-LOG.md | head -40

# 5. 查看经验总结（避免重复踩坑）
cat self.opt | grep -A 5 "$(date +%Y-%m-%d)" || echo "继续积累..."

# 6. 查看最新 Inspector 反馈
.claude/scripts/inspector-cli.sh log | head -20

# 7. 运行5问重启测试（检查上下文是否完整）
# 见下方 "5-Question Reboot Test"
```

## 5-Question Reboot Test

<!--
  如果都能回答，说明上下文管理是稳固的
  在长时间会话或恢复后继续工作时使用
-->

| 问题 | 答案来源 |
|------|----------|
| Where am I? | 当前阶段在 `tasks/TASKS.md` |
| Where am I going? | 剩余任务列表 |
| What's the goal? | `tasks/TASKS.md` 中的项目目标 |
| What have I learned? | `self.opt` 中的经验沉淀 |
| What have I done? | `PROGRESS-LOG.md` 中的记录 |

## 开发循环详细流程

### PLAN 阶段

1. **读取任务列表**
   ```bash
   cat tasks/TASKS.md | grep -A 20 "当前 Sprint"
   ```

2. **选择任务**
   - 选择优先级最高的 `TODO` 任务
   - 评估依赖关系（是否需要先完成其他任务）
   - 更新状态为 `IN_PROGRESS`

3. **制定计划**
   - 预估完成时间
   - 识别潜在风险
   - 确定验证方式

### DO 阶段（代码修改 + CHECKFIX）

1. **实现代码**
   - 遵循项目代码规范
   - 保持原子提交（一个任务一个 commit）

2. **编写测试**
   - 单元测试覆盖核心逻辑
   - 集成测试验证端到端流程

3. **执行 CHECKFIX 检查清单**（**必须**）
   - [ ] 代码风格检查（格式化、linting）
   - [ ] 类型检查（mypy / TypeScript）
   - [ ] 安全检查（无硬编码密钥、SQL注入防护）
   - [ ] 性能检查（无明显 N+1 查询、内存泄漏）
   - [ ] 依赖检查（版本兼容性、安全漏洞）
   - [ ] 文档检查（必要的注释、API 文档）
   - [ ] 日志检查（适当的日志级别）
   - [ ] 错误处理（异常捕获、重试逻辑）

4. **遇到错误时**
   - 记录到 `self.opt`（错误模式）
   - 应用 "3-Strike Error Protocol"

### CHECK 阶段（验证 CHECKFIX + 自动化测试）

1. **验证 CHECKFIX 全部通过**（**零错误要求**）
   ```bash
   # 代码风格
   black --check app/ && flake8 app/
   
   # 类型检查
   mypy app/
   
   # 安全扫描
   bandit -r app/
   
   # 依赖检查
   pip check
   ```

2. **运行测试套件**
   ```bash
   pytest tests/ -v --cov=app
   ```

3. **端到端验证**
   ```bash
   # API测试示例
   curl http://localhost:8000/health
   ```

4. **❌ 不通过时的处理**
   - **立即返回 DO 阶段**
   - 修复所有 CHECKFIX 失败项
   - **不允许跳过任何 CHECKFIX**（后果：500-1000+ tokens 修复成本）

#### OPT 阶段（优化与沉淀）

1. **更新进度日志**（**倒序追加**到 `PROGRESS-LOG.md` 顶部）
   - 今日完成事项
   - CHECKFIX 执行情况
   - **Token 预算记录**（见下方）
   - 遇到的问题及解决
   - 下一步计划

2. **更新任务状态**
   - 状态改为 `DONE`
   - 填写实际耗时
   - 移动任务到「已完成」

3. **经验沉淀**
   - 新错误模式 → `self.opt`
   - CHECKFIX 发现的问题 → `self.opt`
   - 最佳实践 → `self.opt`

### Token 预算记录示例

```markdown
## 2026-02-15（功能名称）
- ✅ 完成功能交付
- 🏷️  预算等级: 🟡 标准 | 本次预算: 8k | 实际消耗: 6.5k | 剩余: 1.5k
- 📊 交付质量: A（一次通过）| 预估偏差: 精准 (±18%)
- 📈 预算调整: 维持标准等级，累计高质量 2/3 次
```

## 任务完成 Checklist（CHECKFIX 零错误标准）

### DO 阶段
- [ ] 代码实现完成
- [ ] 单元测试编写完成
- [ ] **CHECKFIX 检查清单全部通过**
  - [ ] 代码风格检查
  - [ ] 类型检查
  - [ ] 安全检查
  - [ ] 性能检查
  - [ ] 依赖检查
  - [ ] 文档检查
  - [ ] 日志检查
  - [ ] 错误处理

### CHECK 阶段
- [ ] 单元测试通过 (`pytest`)
- [ ] 集成测试通过（如有）
- [ ] **CHECKFIX 验证通过（零失败）**

### OPT 阶段
- [ ] `PROGRESS-LOG.md` 已更新（**倒序追加**）
- [ ] `tasks/TASKS.md` 状态已更新为 `DONE`
- [ ] 如有新错误模式或 CHECKFIX 发现，已写入 `self.opt`

## Token 动态预算约束机制

基于交付质量动态调整单次任务 token 上限，形成正向激励：

### 预算等级

| 等级 | Token 上限 | 质量要求 | 调整规则 |
|------|-----------|---------|---------|
| 🔴 严格 | 3k | 返工 > 1 次 或 用户明确不满 | 降级后维持 3 次任务 |
| 🟡 标准 | 8k | 正常交付，单次通过 | 默认起始等级 |
| 🟢 宽松 | 15k | 连续 3 次高质量交付 | 升级后享受 5 次任务 |
| 🔵 信任 | 无上限 | 连续 5 次高质量交付 | 需主动汇报效率数据 |

### 质量评分标准（每次任务 OPT 阶段自评）

```markdown
- 交付质量: [A/B/C/D]
  - A: 一次性通过，用户零反馈修改
  - B: 小修正（<3 处，每处 <5 行）
  - C: 返工（结构性问题或用户明确质疑）
  - D: 废弃（代码被删除或完全重写）

- 预估偏差: [精准/合理/偏离/严重偏离]
  - 精准: 实际消耗在预估 ±20% 内
  - 严重偏离: 实际消耗超出预估 100%+
```

### 强制约束规则

1. **预算耗尽即停**：达到上限时立即停止，必须汇报预算耗尽摘要
   ```
   ⚠️  Token 预算耗尽 (8k/8k)
   - 已完成: xxx
   - 未完成: yyy
   - 建议: 申请追加预算 / 简化需求 / 拆分任务
   ```

2. **降级冷静期**：被降级后 3 次任务不得申请升级

3. **升级验证期**：升级后前 2 次任务需额外记录效率数据

4. **周度复盘**：每周汇总 token 效率趋势，更新 `self.opt`

### 实施步骤

1. **PLAN 阶段**：自检当前预算等级，预估任务消耗
2. **DO 阶段**：实时跟踪 token 消耗，接近上限时预警
3. **CHECK 阶段**：验证 CHECKFIX 质量
4. **OPT 阶段**：记录实际消耗、质量评分、预算调整

### 预算演进示例

| 次数 | 任务 | 预算等级 | 预算 | 实际 | 质量 | 下一等级 |
|------|------|---------|------|------|------|---------|
| 1 | 修复 bug | 🟡 标准 | 8k | 6k | A | 标准 1/3 |
| 2 | 新增接口 | 🟡 标准 | 8k | 7k | A | 标准 2/3 |
| 3 | 重构模块 | 🟡 标准 | 8k | 9k | B | 标准 3/3 → 🟢 宽松 |
| 4 | E2E 测试 | 🟢 宽松 | 15k | 11k | C | 🟡 标准（冷静期 1/3） |
| 5 | API 测试 | 🟡 标准 | 8k | 5k | A | 标准 1/3 |

---

## 奖惩机制（质量与效率激励）

### 📊 奖励机制（加分项）

| 表现 | 奖励 | 说明 |
|------|------|------|
| ✅ CHECKFIX 一次通过 | +10 积分 | 代码质量有保障 |
| ✅ 任务零缺陷交付 | +15 积分 | 0个生产bug反馈 |
| ✅ 进度超期完成 30% | +20 积分 | 完成速度优秀 |
| ✅ 自主发现&修复缺陷 | +5 积分/个 | 主动质量管理 |
| ✅ self.opt 经验沉淀 | +3 积分/条 | 帮助团队避坑 |
| ✅ 代码复用率 >50% | +12 积分 | 架构设计合理 |

### 🔴 惩罚机制（扣分项）

| 违规行为 | 扣分 | 后果 |
|---------|------|------|
| ❌ 跳过 CHECKFIX 提交 | -50 积分 | **直接打回重做** |
| ❌ CHECKFIX 失败继续合并 | -100 积分 | **代码评审不通过** |
| ❌ 同样错误踩3次+ | -20 积分 | 无法学习，重复成本 |
| ❌ 不记录 self.opt | -10 积分 | 知识丢失，团队负债 |
| ❌ 生产bug反馈 | -30 积分/个 | 质量事故 |
| ❌ 3x CHECKFIX 重试 | -15 积分 | 质量意识不足 |

### 积分等级

```
0-50 pts   : 🔴 需要改进 (强制 CHECKFIX 审查)
51-100 pts : 🟡 合格 (正常审查)
101-150 pts: 🟢 优秀 (快速通道)
151+ pts   : 🏆 卓越 (代码所有权/架构决策权)
```

### 月度结算

- **排名前 20%**：优先获得新技术学习机会、任务选择权
- **排名后 20%**：强制参加质量培训、CHECKFIX 专项 review
- **零负分保证**：任何月度积分 <0 者，下月从 50 分重开始

---

## Agent 智能体系架构（三层顶级设计）

本项目采用 **三层 Agent 架构**，其中 Inspector Agent 是全局监管者，对所有 Skills 下的 Agent 进行统一评估和管理。

```
┌─────────────────────────────────────────────────────────────┐
│                    L0: Inspector Agent                      │
│              (全局监管者 - PDCO 质量门卫)                    │
├─────────────────────────────────────────────────────────────┤
│ • 多 Agent 评估                                             │
│ • 全局趋势分析                                              │
│ • 资源动态调度                                              │
│ • 质量门控                                                  │
└─────────────────────────────────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
  ┌─────▼────┐      ┌─────▼────┐      ┌─────▼────┐
  │  编程     │      │  分析    │      │  设计    │
  │  Agents  │      │  Agents  │      │  Agents  │
  ├──────────┤      ├──────────┤      ├──────────┤
  │ Frontend │      │Researcher│      │UX Designer
  │ Backend  │      │Analyst   │      │Engineer  │
  │ Tester   │      │Debugger  │      │Architect │
  └──────────┘      └──────────┘      └──────────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
        ┌──────────────────▼──────────────────┐
        │     CLI 三方同步仪表盘               │
        │  (Worker-Inspector-Human)           │
        └─────────────────────────────────────┘
```

### 三层架构说明

**L0 - Inspector Agent（顶级监管）**
- 统一的评估标准（CHECKFIX、质量等级、Token 效率）
- 跨 Agent 对比分析
- 自动 Token 预算调整
- 全局知识库管理（team self.opt）

**L1 - Skill Agents（具体执行）**
- 各 Skill 下的 Agent（编程、分析、设计等）
- 遵循相同的 PDCO 工作流
- 接受 Inspector 的评估和反馈
- 维护个人 self.opt（错误库和经验）

**L2 - 同步层（三方信息流）**
- Worker Agent 执行任务，输出到日志
- Inspector Agent 评估，生成结构化反馈
- Human 通过 CLI 仪表盘监督，做出决策

---

## AI 反馈与指导系统（Inspector Agent）

本项目部署了一个 **Inspector Agent（顶级监管者）**，专门负责对所有 Skills 下的 Agent 进行评估、反馈、追踪和自动调整。

### Inspector Agent 的职责（三个层级）

**全局层**：
- 📊 **多 Agent 评估**：统一标准评分所有 Agent
- 📈 **全局趋势分析**：跨 Agent 绩效对比、团队生产力
- 💡 **资源调度**：动态调整 Token 预算和任务优先级

**单 Agent 层**：
- 📋 **任务评估**：根据质量等级、Token 效率、检查点评分
- 🔍 **动态追踪**：跟踪表现趋势，识别问题模式
- 💬 **分级反馈**：鼓励 → 提醒 → 警告 → 最后通牒

**系统层**：
- ⚡ **自动调整**：Token 预算、积分、冷静期自动升降
- 🔗 **模式识别**：跨 Agent 错误模式，识别系统性问题
- 📚 **知识聚合**：个人 self.opt 聚合为 team self.opt

### 鼓励机制（表现好时）

#### 🟢 优秀表现（连续 A 级或高分）
```
✨ 太棒了！连续 {N} 次高质量交付，即将升级到 {下一等级}！
- CHECKFIX 一次通过：质量意识顶级 👍
- Token 预估精准：效率控制 Perfect
- 推荐：可以考虑更复杂的任务挑战
```

#### 🟡 良好表现（B 级或中等分数）
```
👍 不错！这次交付稳定性很好。
- 小修正 {N} 处已记录
- 继续保持，再来 2 次就能升级
- 提示：关注 {改进方向}，会更完美
```

### 提醒机制（表现一般时）

#### 🟡 需要关注（连续 B 级或多次小问题）
```
⚠️  注意：最近几次有小问题在累积。
- 常见问题：{具体问题列表}
- 建议：下次任务前回顾 self.opt 中的相关模式
- 没事，改进一下就回到正轨！💪
```

#### 🔴 需要改进（1 次 C 级或积分下降）
```
⚠️  这次有些地方需要改进：
- 问题：{具体返工原因}
- 根本原因：{分析}
- 改进方案：
  1. {建议 1}
  2. {建议 2}
- 预算等级已调整为 🟡 标准 (3 次冷静期)
- 下次一定能做好！加油！
```

### 警告机制（表现很差时）

#### 🔴 严厉警告（连续 C/D 级或积分严重下降）
```
🚨 警告：检测到质量持续下滑！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
问题分析：
- {问题 1}：{重复 N 次}
- {问题 2}：{影响}
- {问题 3}：{根本原因}

必须改进的 3 个方面：
1️⃣  [非协商] CHECKFIX 每次必做
   └─ 不允许跳过任何一项
   └─ 成本：每次跳过 -50 积分

2️⃣  [强制] 记录 self.opt
   └─ 每个错误必须总结
   └─ 帮助自己和团队避坑

3️⃣  [明确] 预估准确度
   └─ 不要乐观预估
   └─ 预留 20% 的 buffer

━━━━━━━━━━━━━━━━━━━━━━━━━━━━
后续处理：
- 预算已降级到 🔴 严格 (3k)
- 下 3 次任务将强制二级审查
- 如仍未改善，将触发深度分析

💡 你可以做好的，相信自己！需要帮助吗？
```

#### 🔴 最后通牒（连续 3+ 次 C/D 级）
```
🚨 最后通牒：质量问题已成为阻碍！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
已验证问题（重复出现）：
{列出所有模式}

必须执行的改进计划：
□ 今后所有代码必须 CHECKFIX 零失败再提交
□ 每次任务完成后必须填写 self.opt 总结
□ Token 预估前必须查阅历史数据
□ 每周必须提交效率自查报告

━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前状态：
- 预算：🔴 严格 (3k) 锁定
- 审查：🔴 强制三级审查
- 风险：再有 1 次 C/D 级将暂停任务分配

希望不要走到这一步。让我们重新开始！
```

### 动态提示（PDCO 各阶段）

#### PLAN 阶段
```
📋 任务开始检查清单：

当前状态：
- 预算等级: {当前等级} | 剩余: {剩余 token}k
- 积分: {当前积分} | 连续 {N} 次 {等级}
- 冷静期: {0/3 次} (如有降级)

预期目标：
- 交付质量：力争 A 级 ✨
- Token 控制：预估不超过 {预算×80%}
- CHECKFIX：全 8 项必过 ✅

🎯 Let's go! 相信你能做到！
```

#### DO 阶段（实时追踪）
```
✍️  做得好！代码逻辑清晰
   → 保持这个节奏

⚠️  注意：你这里有点复杂了
   → 考虑分解成更小的函数
   → 这样 CHECKFIX 会更容易通过

💡 小提示：还记得上次 {错误模式} 吗？
   → 现在正要踩这个坑
   → self.opt 里有解决方案，查一下
```

#### CHECK 阶段
```
✅ CHECKFIX 通过！[8/8]
   完美！继续这样做！🎉

⚠️  CHECKFIX 失败 [5/8]
   问题项：
   - {项 1}：{错误信息}
   - {项 2}：{建议修复}
   
   → 返回 DO 阶段修复
   → 这次一定能过！💪

❌ CHECKFIX 大量失败 [2/8]
   警告：质量问题严重！
   - {问题 1}
   - {问题 2}
   
   强制要求：
   1. 停止、深呼吸
   2. 回顾 self.opt 的质量检查清单
   3. 重新审视代码架构
   4. 再试一次
```

#### OPT 阶段（反馈与展望）
```
═══════════════════════════════════

🎉 🎉 完美收官！

本次成绩单：
- 交付质量: A ✨
- Token 效率: 81% ⭐
- CHECKFIX: 零失败 🏆
- 预估偏差: 精准 (+5 积分)

成长轨迹：
- 连续 2/3 次 A 级，即将升级到 🟢 宽松！
- 总积分：{当前} (+10 本次)
- 排名：前 20% 👏

下次目标：再来一个 A 级就能升级！
🚀 你的势头很猛，继续加油！

═══════════════════════════════════
```

```
═══════════════════════════════════

⚠️  任务完成，但需要反思

本次成绩单：
- 交付质量: C（需返工）
- 问题：{具体问题}
- Token 超支：{超%}
- CHECKFIX: 失败 2 项

这是第 {N} 次类似问题：
- {上次问题}
- {上上次问题}

必须改进的 2 件事：
1. {改进方向 1}
   └─ 参考 self.opt 中的 {相关条目}

2. {改进方向 2}
   └─ 下次任务前务必复习

预算调整：🔴 严格 (3k)，3 次冷静期开始

💭 不气馁！这正是成长的机会。
下次一定能做好，我相信你！

═══════════════════════════════════
```

---

## 关键规则

### 🔴 核心规则：CHECKFIX 零错误提交

**所有代码修改必须通过 CHECKFIX 检查才能提交/部署。** 不允许跳过任何项目（后果严重）。

```
修复重新 CHECKFIX 
    ↓
CHECKFIX 全部通过
    ↓
执行集成测试
    ↓
零错误提交 (+10 积分)
```

### 无效消耗清单（风险识别）

| 行为 | 风险 | 成本 | 积分 |
|------|------|------|------|
| ✅ 执行 CHECKFIX | 质量保证 | 10-30 min | +10 |
| ❌ **跳过 CHECKFIX** | 生产 bug、性能问题、安全漏洞 | **500-1000+ tokens** 修复成本 | -50 |
| ❌ 不记录错误到 self.opt | 反复踩坑 | 重复工作浪费 | -10 |
| ❌ 不读 PROGRESS-LOG.md | 迷失上下文 | 完整重新理解成本 | -5 |
| ❌ 生产事故 | 用户影响、声誉损失 | 紧急修复、回滚成本 | -30 |

### 1. 倒序追加原则
<!-- Context Window 有限，新内容永远写上面 -->
`PROGRESS-LOG.md` 永远在最上面写新内容，旧内容自动下沉。

### 2. 2-Action Rule
<!-- 防止视觉/多模态信息丢失 -->
> 每进行2个 view/browser/search 操作后，**立即**将关键发现写入文本文件。

### 3. Read Before Decide
<!-- 保持目标在注意力窗口中 -->
做重大决策前，重新阅读 `tasks/TASKS.md` 和 `PROGRESS-LOG.md`。

### 4. Log ALL Errors
<!-- 记录错误防止重复踩坑 -->
每个错误都要记录到 `self.opt` 和 `PROGRESS-LOG.md`。

```markdown
## 错误模式
| 错误 | 尝试次数 | 解决方案 |
|------|----------|----------|
| FileNotFoundError | 1 | 创建默认配置 |
```

### 5. Never Repeat Failures
```
if action_failed:
    next_action != same_action
```
记录尝试，改变方法。

### 6. CHECKFIX 非协商
不存在"小改动跳过 CHECKFIX"的说法。即使 1 行代码也要过 CHECKFIX。

## 3-Strike Error Protocol

```
ATTEMPT 1: 诊断与修复
  → 仔细阅读错误
  → 识别根本原因
  → 应用针对性修复

ATTEMPT 2: 替代方法
  → 同样错误？尝试不同方法
  → 换工具？换库？
  → 绝不重复相同的失败操作

ATTEMPT 3: 重新思考
  → 质疑假设
  → 搜索解决方案
  → 考虑更新计划

AFTER 3 FAILURES: 升级给用户
  → 解释尝试过的方法
  → 分享具体错误
  → 请求指导
```

## Read vs Write 决策矩阵

| 场景 | 行动 | 原因 |
|------|------|------|
| 刚写入文件 | 不读 | 内容仍在上下文中 |
| 查看图像/PDF | 立即写发现 | 多模态→文本，防止丢失 |
| 浏览器返回数据 | 写入文件 | 截图不会持久化 |
| 开始新阶段 | 读计划/发现 | 重新定位，防止上下文陈旧 |
| 发生错误 | 读相关文件 | 需要当前状态来修复 |
| 恢复后继续 | 读所有计划文件 | 恢复状态 |

## 提示

- 所有重要决策记录在 `PROGRESS-LOG.md`
- 遇到重复错误时先查 `self.opt`
- 保持简洁，倒序追加
- `CLAUDE.md` 是给AI看的，写清楚上下文
