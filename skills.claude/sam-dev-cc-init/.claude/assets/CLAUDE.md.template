# CLAUDE.md
<!--
  WHAT: 这是AI助手的上下文指南，让Claude快速理解项目结构和开发规范
  WHY: 减少重复解释，保持开发一致性，实现高效的PDCA循环
  WHEN: 新项目初始化时创建，随着项目演进更新
-->

This file provides guidance to Claude Code when working with code in this repository.

## 快速开始

- 工作目录：`/app`
- 常用命令：
  - 测试：`pytest tests/ -v`
  - 运行：`python -m app.main`

## PDCO 开发循环（CHECKFIX 零错误部署）

<!--
  PDCO = Plan-Do-Check-Optimize
  核心理念：Context Window = RAM (易失，有限), Filesystem = Disk (持久，无限)
  关键改进：Do 阶段必须执行 CHECKFIX，Check 阶段验证 CHECKFIX 全部通过
  重要信息必须写入文件！
-->

```
┌─────────────────────────────────────────────────────────────┐
│             PDCO 开发循环（CHECKFIX 零错误）                 │
├─────────────────────────────────────────────────────────────┤
│  1. PLAN → 读取 tasks/TASKS.md，查看并领取任务              │
│  2. DO   → 代码修改 + 执行 CHECKFIX 检查清单                │
│  3. CHECK→ 验证 CHECKFIX 全部通过 + pytest/集成验证         │
│  4. OPT  → 更新 PROGRESS-LOG.md + 更新任务 + self.opt 沉淀   │
│                                                              │
│  🔴 核心原则：所有代码修改必须 CHECKFIX 零错误提交/部署      │
└─────────────────────────────────────────────────────────────┘
```

### 文件对应关系

| 阶段 | 文件 | 用途 | 更新方式 |
|------|------|------|----------|
| PLAN | `tasks/TASKS.md` | 任务列表与状态管理 | 手动编辑 |
| DO | 代码目录 | 实现 + **CHECKFIX 检查** | 编码 |
| CHECK | `.checkfix/` + `pytest` | **验证 CHECKFIX** + 测试 | 命令 |
| OPT | `PROGRESS-LOG.md` + `self.opt` | 进度日志 + 经验沉淀 | 手动编辑 |

## 每日启动流程

```bash
# 1. 查看今日任务
cat tasks/TASKS.md | grep -A 10 "当前 Sprint"

# 2. 回顾昨日进度
cat PROGRESS-LOG.md | head -40

# 3. 查看经验总结（避免重复踩坑）
cat self.opt | grep -A 5 "$(date +%Y-%m-%d)" || echo "继续积累..."

# 4. 运行5问重启测试（检查上下文是否完整）
# 见下方 "5-Question Reboot Test"
```

## 5-Question Reboot Test

<!--
  如果都能回答，说明上下文管理是稳固的
  在长时间会话或恢复后继续工作时使用
-->

| 问题 | 答案来源 |
|------|----------|
| Where am I? | 当前阶段在 `tasks/TASKS.md` |
| Where am I going? | 剩余任务列表 |
| What's the goal? | `tasks/TASKS.md` 中的项目目标 |
| What have I learned? | `self.opt` 中的经验沉淀 |
| What have I done? | `PROGRESS-LOG.md` 中的记录 |

## 开发循环详细流程

### PLAN 阶段

1. **读取任务列表**
   ```bash
   cat tasks/TASKS.md | grep -A 20 "当前 Sprint"
   ```

2. **选择任务**
   - 选择优先级最高的 `TODO` 任务
   - 评估依赖关系（是否需要先完成其他任务）
   - 更新状态为 `IN_PROGRESS`

3. **制定计划**
   - 预估完成时间
   - 识别潜在风险
   - 确定验证方式

### DO 阶段（代码修改 + CHECKFIX）

1. **实现代码**
   - 遵循项目代码规范
   - 保持原子提交（一个任务一个 commit）

2. **编写测试**
   - 单元测试覆盖核心逻辑
   - 集成测试验证端到端流程

3. **执行 CHECKFIX 检查清单**（**必须**）
   - [ ] 代码风格检查（格式化、linting）
   - [ ] 类型检查（mypy / TypeScript）
   - [ ] 安全检查（无硬编码密钥、SQL注入防护）
   - [ ] 性能检查（无明显 N+1 查询、内存泄漏）
   - [ ] 依赖检查（版本兼容性、安全漏洞）
   - [ ] 文档检查（必要的注释、API 文档）
   - [ ] 日志检查（适当的日志级别）
   - [ ] 错误处理（异常捕获、重试逻辑）

4. **遇到错误时**
   - 记录到 `self.opt`（错误模式）
   - 应用 "3-Strike Error Protocol"

### CHECK 阶段（验证 CHECKFIX + 自动化测试）

1. **验证 CHECKFIX 全部通过**（**零错误要求**）
   ```bash
   # 代码风格
   black --check app/ && flake8 app/
   
   # 类型检查
   mypy app/
   
   # 安全扫描
   bandit -r app/
   
   # 依赖检查
   pip check
   ```

2. **运行测试套件**
   ```bash
   pytest tests/ -v --cov=app
   ```

3. **端到端验证**
   ```bash
   # API测试示例
   curl http://localhost:8000/health
   ```

4. **❌ 不通过时的处理**
   - **立即返回 DO 阶段**
   - 修复所有 CHECKFIX 失败项
   - **不允许跳过任何 CHECKFIX**（后果：500-1000+ tokens 修复成本）

#### OPT 阶段（优化与沉淀）

1. **更新进度日志**（**倒序追加**到 `PROGRESS-LOG.md` 顶部）
   - 今日完成事项
   - CHECKFIX 执行情况
   - **Token 预算记录**（见下方）
   - 遇到的问题及解决
   - 下一步计划

2. **更新任务状态**
   - 状态改为 `DONE`
   - 填写实际耗时
   - 移动任务到「已完成」

3. **经验沉淀**
   - 新错误模式 → `self.opt`
   - CHECKFIX 发现的问题 → `self.opt`
   - 最佳实践 → `self.opt`

### Token 预算记录示例

```markdown
## 2026-02-15（功能名称）
- ✅ 完成功能交付
- 🏷️  预算等级: 🟡 标准 | 本次预算: 8k | 实际消耗: 6.5k | 剩余: 1.5k
- 📊 交付质量: A（一次通过）| 预估偏差: 精准 (±18%)
- 📈 预算调整: 维持标准等级，累计高质量 2/3 次
```

## 任务完成 Checklist（CHECKFIX 零错误标准）

### DO 阶段
- [ ] 代码实现完成
- [ ] 单元测试编写完成
- [ ] **CHECKFIX 检查清单全部通过**
  - [ ] 代码风格检查
  - [ ] 类型检查
  - [ ] 安全检查
  - [ ] 性能检查
  - [ ] 依赖检查
  - [ ] 文档检查
  - [ ] 日志检查
  - [ ] 错误处理

### CHECK 阶段
- [ ] 单元测试通过 (`pytest`)
- [ ] 集成测试通过（如有）
- [ ] **CHECKFIX 验证通过（零失败）**

### OPT 阶段
- [ ] `PROGRESS-LOG.md` 已更新（**倒序追加**）
- [ ] `tasks/TASKS.md` 状态已更新为 `DONE`
- [ ] 如有新错误模式或 CHECKFIX 发现，已写入 `self.opt`

## Token 动态预算约束机制

基于交付质量动态调整单次任务 token 上限，形成正向激励：

### 预算等级

| 等级 | Token 上限 | 质量要求 | 调整规则 |
|------|-----------|---------|---------|
| 🔴 严格 | 3k | 返工 > 1 次 或 用户明确不满 | 降级后维持 3 次任务 |
| 🟡 标准 | 8k | 正常交付，单次通过 | 默认起始等级 |
| 🟢 宽松 | 15k | 连续 3 次高质量交付 | 升级后享受 5 次任务 |
| 🔵 信任 | 无上限 | 连续 5 次高质量交付 | 需主动汇报效率数据 |

### 质量评分标准（每次任务 OPT 阶段自评）

```markdown
- 交付质量: [A/B/C/D]
  - A: 一次性通过，用户零反馈修改
  - B: 小修正（<3 处，每处 <5 行）
  - C: 返工（结构性问题或用户明确质疑）
  - D: 废弃（代码被删除或完全重写）

- 预估偏差: [精准/合理/偏离/严重偏离]
  - 精准: 实际消耗在预估 ±20% 内
  - 严重偏离: 实际消耗超出预估 100%+
```

### 强制约束规则

1. **预算耗尽即停**：达到上限时立即停止，必须汇报预算耗尽摘要
   ```
   ⚠️  Token 预算耗尽 (8k/8k)
   - 已完成: xxx
   - 未完成: yyy
   - 建议: 申请追加预算 / 简化需求 / 拆分任务
   ```

2. **降级冷静期**：被降级后 3 次任务不得申请升级

3. **升级验证期**：升级后前 2 次任务需额外记录效率数据

4. **周度复盘**：每周汇总 token 效率趋势，更新 `self.opt`

### 实施步骤

1. **PLAN 阶段**：自检当前预算等级，预估任务消耗
2. **DO 阶段**：实时跟踪 token 消耗，接近上限时预警
3. **CHECK 阶段**：验证 CHECKFIX 质量
4. **OPT 阶段**：记录实际消耗、质量评分、预算调整

### 预算演进示例

| 次数 | 任务 | 预算等级 | 预算 | 实际 | 质量 | 下一等级 |
|------|------|---------|------|------|------|---------|
| 1 | 修复 bug | 🟡 标准 | 8k | 6k | A | 标准 1/3 |
| 2 | 新增接口 | 🟡 标准 | 8k | 7k | A | 标准 2/3 |
| 3 | 重构模块 | 🟡 标准 | 8k | 9k | B | 标准 3/3 → 🟢 宽松 |
| 4 | E2E 测试 | 🟢 宽松 | 15k | 11k | C | 🟡 标准（冷静期 1/3） |
| 5 | API 测试 | 🟡 标准 | 8k | 5k | A | 标准 1/3 |

---

## 奖惩机制（质量与效率激励）

### 📊 奖励机制（加分项）

| 表现 | 奖励 | 说明 |
|------|------|------|
| ✅ CHECKFIX 一次通过 | +10 积分 | 代码质量有保障 |
| ✅ 任务零缺陷交付 | +15 积分 | 0个生产bug反馈 |
| ✅ 进度超期完成 30% | +20 积分 | 完成速度优秀 |
| ✅ 自主发现&修复缺陷 | +5 积分/个 | 主动质量管理 |
| ✅ self.opt 经验沉淀 | +3 积分/条 | 帮助团队避坑 |
| ✅ 代码复用率 >50% | +12 积分 | 架构设计合理 |

### 🔴 惩罚机制（扣分项）

| 违规行为 | 扣分 | 后果 |
|---------|------|------|
| ❌ 跳过 CHECKFIX 提交 | -50 积分 | **直接打回重做** |
| ❌ CHECKFIX 失败继续合并 | -100 积分 | **代码评审不通过** |
| ❌ 同样错误踩3次+ | -20 积分 | 无法学习，重复成本 |
| ❌ 不记录 self.opt | -10 积分 | 知识丢失，团队负债 |
| ❌ 生产bug反馈 | -30 积分/个 | 质量事故 |
| ❌ 3x CHECKFIX 重试 | -15 积分 | 质量意识不足 |

### 积分等级

```
0-50 pts   : 🔴 需要改进 (强制 CHECKFIX 审查)
51-100 pts : 🟡 合格 (正常审查)
101-150 pts: 🟢 优秀 (快速通道)
151+ pts   : 🏆 卓越 (代码所有权/架构决策权)
```

### 月度结算

- **排名前 20%**：优先获得新技术学习机会、任务选择权
- **排名后 20%**：强制参加质量培训、CHECKFIX 专项 review
- **零负分保证**：任何月度积分 <0 者，下月从 50 分重开始

---

## 关键规则

### 🔴 核心规则：CHECKFIX 零错误提交

**所有代码修改必须通过 CHECKFIX 检查才能提交/部署。** 不允许跳过任何项目（后果严重）。

```
修复重新 CHECKFIX 
    ↓
CHECKFIX 全部通过
    ↓
执行集成测试
    ↓
零错误提交 (+10 积分)
```

### 无效消耗清单（风险识别）

| 行为 | 风险 | 成本 | 积分 |
|------|------|------|------|
| ✅ 执行 CHECKFIX | 质量保证 | 10-30 min | +10 |
| ❌ **跳过 CHECKFIX** | 生产 bug、性能问题、安全漏洞 | **500-1000+ tokens** 修复成本 | -50 |
| ❌ 不记录错误到 self.opt | 反复踩坑 | 重复工作浪费 | -10 |
| ❌ 不读 PROGRESS-LOG.md | 迷失上下文 | 完整重新理解成本 | -5 |
| ❌ 生产事故 | 用户影响、声誉损失 | 紧急修复、回滚成本 | -30 |

### 1. 倒序追加原则
<!-- Context Window 有限，新内容永远写上面 -->
`PROGRESS-LOG.md` 永远在最上面写新内容，旧内容自动下沉。

### 2. 2-Action Rule
<!-- 防止视觉/多模态信息丢失 -->
> 每进行2个 view/browser/search 操作后，**立即**将关键发现写入文本文件。

### 3. Read Before Decide
<!-- 保持目标在注意力窗口中 -->
做重大决策前，重新阅读 `tasks/TASKS.md` 和 `PROGRESS-LOG.md`。

### 4. Log ALL Errors
<!-- 记录错误防止重复踩坑 -->
每个错误都要记录到 `self.opt` 和 `PROGRESS-LOG.md`。

```markdown
## 错误模式
| 错误 | 尝试次数 | 解决方案 |
|------|----------|----------|
| FileNotFoundError | 1 | 创建默认配置 |
```

### 5. Never Repeat Failures
```
if action_failed:
    next_action != same_action
```
记录尝试，改变方法。

### 6. CHECKFIX 非协商
不存在"小改动跳过 CHECKFIX"的说法。即使 1 行代码也要过 CHECKFIX。

## 3-Strike Error Protocol

```
ATTEMPT 1: 诊断与修复
  → 仔细阅读错误
  → 识别根本原因
  → 应用针对性修复

ATTEMPT 2: 替代方法
  → 同样错误？尝试不同方法
  → 换工具？换库？
  → 绝不重复相同的失败操作

ATTEMPT 3: 重新思考
  → 质疑假设
  → 搜索解决方案
  → 考虑更新计划

AFTER 3 FAILURES: 升级给用户
  → 解释尝试过的方法
  → 分享具体错误
  → 请求指导
```

## Read vs Write 决策矩阵

| 场景 | 行动 | 原因 |
|------|------|------|
| 刚写入文件 | 不读 | 内容仍在上下文中 |
| 查看图像/PDF | 立即写发现 | 多模态→文本，防止丢失 |
| 浏览器返回数据 | 写入文件 | 截图不会持久化 |
| 开始新阶段 | 读计划/发现 | 重新定位，防止上下文陈旧 |
| 发生错误 | 读相关文件 | 需要当前状态来修复 |
| 恢复后继续 | 读所有计划文件 | 恢复状态 |

## 提示

- 所有重要决策记录在 `PROGRESS-LOG.md`
- 遇到重复错误时先查 `self.opt`
- 保持简洁，倒序追加
- `CLAUDE.md` 是给AI看的，写清楚上下文
